{"ast":null,"code":"/** @license React v16.5.2\n * schedule.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n    /* eslint-disable no-var */\n    // TODO: Currently there's only a single priority level, Deferred. Will add\n    // additional priorities.\n\n    var DEFERRED_TIMEOUT = 5000; // Callbacks are stored as a circular, doubly linked list.\n\n    var firstCallbackNode = null;\n    var isPerformingWork = false;\n    var isHostCallbackScheduled = false;\n    var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n    var timeRemaining;\n\n    if (hasNativePerformanceNow) {\n      timeRemaining = function () {\n        // We assume that if we have a performance timer that the rAF callback\n        // gets a performance timer value. Not sure if this is always true.\n        var remaining = getFrameDeadline() - performance.now();\n        return remaining > 0 ? remaining : 0;\n      };\n    } else {\n      timeRemaining = function () {\n        // Fallback to Date.now()\n        var remaining = getFrameDeadline() - Date.now();\n        return remaining > 0 ? remaining : 0;\n      };\n    }\n\n    var deadlineObject = {\n      timeRemaining: timeRemaining,\n      didTimeout: false\n    };\n\n    function ensureHostCallbackIsScheduled() {\n      if (isPerformingWork) {\n        // Don't schedule work yet; wait until the next time we yield.\n        return;\n      } // Schedule the host callback using the earliest timeout in the list.\n\n\n      var timesOutAt = firstCallbackNode.timesOutAt;\n\n      if (!isHostCallbackScheduled) {\n        isHostCallbackScheduled = true;\n      } else {\n        // Cancel the existing host callback.\n        cancelCallback();\n      }\n\n      requestCallback(flushWork, timesOutAt);\n    }\n\n    function flushFirstCallback(node) {\n      var flushedNode = firstCallbackNode; // Remove the node from the list before calling the callback. That way the\n      // list is in a consistent state even if the callback throws.\n\n      var next = firstCallbackNode.next;\n\n      if (firstCallbackNode === next) {\n        // This is the last callback in the list.\n        firstCallbackNode = null;\n        next = null;\n      } else {\n        var previous = firstCallbackNode.previous;\n        firstCallbackNode = previous.next = next;\n        next.previous = previous;\n      }\n\n      flushedNode.next = flushedNode.previous = null; // Now it's safe to call the callback.\n\n      var callback = flushedNode.callback;\n      callback(deadlineObject);\n    }\n\n    function flushWork(didTimeout) {\n      isPerformingWork = true;\n      deadlineObject.didTimeout = didTimeout;\n\n      try {\n        if (didTimeout) {\n          // Flush all the timed out callbacks without yielding.\n          while (firstCallbackNode !== null) {\n            // Read the current time. Flush all the callbacks that expire at or\n            // earlier than that time. Then read the current time again and repeat.\n            // This optimizes for as few performance.now calls as possible.\n            var currentTime = exports.unstable_now();\n\n            if (firstCallbackNode.timesOutAt <= currentTime) {\n              do {\n                flushFirstCallback();\n              } while (firstCallbackNode !== null && firstCallbackNode.timesOutAt <= currentTime);\n\n              continue;\n            }\n\n            break;\n          }\n        } else {\n          // Keep flushing callbacks until we run out of time in the frame.\n          if (firstCallbackNode !== null) {\n            do {\n              flushFirstCallback();\n            } while (firstCallbackNode !== null && getFrameDeadline() - exports.unstable_now() > 0);\n          }\n        }\n      } finally {\n        isPerformingWork = false;\n\n        if (firstCallbackNode !== null) {\n          // There's still work remaining. Request another callback.\n          ensureHostCallbackIsScheduled(firstCallbackNode);\n        } else {\n          isHostCallbackScheduled = false;\n        }\n      }\n    }\n\n    function unstable_scheduleWork(callback, options) {\n      var currentTime = exports.unstable_now();\n      var timesOutAt;\n\n      if (options !== undefined && options !== null && options.timeout !== null && options.timeout !== undefined) {\n        // Check for an explicit timeout\n        timesOutAt = currentTime + options.timeout;\n      } else {\n        // Compute an absolute timeout using the default constant.\n        timesOutAt = currentTime + DEFERRED_TIMEOUT;\n      }\n\n      var newNode = {\n        callback: callback,\n        timesOutAt: timesOutAt,\n        next: null,\n        previous: null\n      }; // Insert the new callback into the list, sorted by its timeout.\n\n      if (firstCallbackNode === null) {\n        // This is the first callback in the list.\n        firstCallbackNode = newNode.next = newNode.previous = newNode;\n        ensureHostCallbackIsScheduled(firstCallbackNode);\n      } else {\n        var next = null;\n        var node = firstCallbackNode;\n\n        do {\n          if (node.timesOutAt > timesOutAt) {\n            // The new callback times out before this one.\n            next = node;\n            break;\n          }\n\n          node = node.next;\n        } while (node !== firstCallbackNode);\n\n        if (next === null) {\n          // No callback with a later timeout was found, which means the new\n          // callback has the latest timeout in the list.\n          next = firstCallbackNode;\n        } else if (next === firstCallbackNode) {\n          // The new callback has the earliest timeout in the entire list.\n          firstCallbackNode = newNode;\n          ensureHostCallbackIsScheduled(firstCallbackNode);\n        }\n\n        var previous = next.previous;\n        previous.next = next.previous = newNode;\n        newNode.next = next;\n        newNode.previous = previous;\n      }\n\n      return newNode;\n    }\n\n    function unstable_cancelScheduledWork(callbackNode) {\n      var next = callbackNode.next;\n\n      if (next === null) {\n        // Already cancelled.\n        return;\n      }\n\n      if (next === callbackNode) {\n        // This is the only scheduled callback. Clear the list.\n        firstCallbackNode = null;\n      } else {\n        // Remove the callback from its position in the list.\n        if (callbackNode === firstCallbackNode) {\n          firstCallbackNode = next;\n        }\n\n        var previous = callbackNode.previous;\n        previous.next = next;\n        next.previous = previous;\n      }\n\n      callbackNode.next = callbackNode.previous = null;\n    } // The remaining code is essentially a polyfill for requestIdleCallback. It\n    // works by scheduling a requestAnimationFrame, storing the time for the start\n    // of the frame, then scheduling a postMessage which gets scheduled after paint.\n    // Within the postMessage handler do as much work as possible until time + frame\n    // rate. By separating the idle call into a separate event tick we ensure that\n    // layout, paint and other browser work is counted against the available time.\n    // The frame rate is dynamically adjusted.\n    // We capture a local reference to any global, in case it gets polyfilled after\n    // this module is initially evaluated. We want to be using a\n    // consistent implementation.\n\n\n    var localDate = Date; // This initialization code may run even on server environments if a component\n    // just imports ReactDOM (e.g. for findDOMNode). Some environments might not\n    // have setTimeout or clearTimeout. However, we always expect them to be defined\n    // on the client. https://github.com/facebook/react/pull/13088\n\n    var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\n    var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined; // We don't expect either of these to necessarily be defined, but we will error\n    // later if they are missing on the client.\n\n    var localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\n    var localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined; // requestAnimationFrame does not run when the tab is in the background. If\n    // we're backgrounded we prefer for that work to happen so that the page\n    // continues to load in the background. So we also schedule a 'setTimeout' as\n    // a fallback.\n    // TODO: Need a better heuristic for backgrounded work.\n\n    var ANIMATION_FRAME_TIMEOUT = 100;\n    var rAFID;\n    var rAFTimeoutID;\n\n    var requestAnimationFrameWithTimeout = function (callback) {\n      // schedule rAF and also a setTimeout\n      rAFID = localRequestAnimationFrame(function (timestamp) {\n        // cancel the setTimeout\n        localClearTimeout(rAFTimeoutID);\n        callback(timestamp);\n      });\n      rAFTimeoutID = localSetTimeout(function () {\n        // cancel the requestAnimationFrame\n        localCancelAnimationFrame(rAFID);\n        callback(exports.unstable_now());\n      }, ANIMATION_FRAME_TIMEOUT);\n    };\n\n    if (hasNativePerformanceNow) {\n      var Performance = performance;\n\n      exports.unstable_now = function () {\n        return Performance.now();\n      };\n    } else {\n      exports.unstable_now = function () {\n        return localDate.now();\n      };\n    }\n\n    var requestCallback;\n    var cancelCallback;\n    var getFrameDeadline;\n\n    if (typeof window === 'undefined') {\n      // If this accidentally gets imported in a non-browser environment, fallback\n      // to a naive implementation.\n      var timeoutID = -1;\n\n      requestCallback = function (callback, absoluteTimeout) {\n        timeoutID = setTimeout(callback, 0, true);\n      };\n\n      cancelCallback = function () {\n        clearTimeout(timeoutID);\n      };\n\n      getFrameDeadline = function () {\n        return 0;\n      };\n    } else if (window._schedMock) {\n      // Dynamic injection, only for testing purposes.\n      var impl = window._schedMock;\n      requestCallback = impl[0];\n      cancelCallback = impl[1];\n      getFrameDeadline = impl[2];\n    } else {\n      if (typeof console !== 'undefined') {\n        if (typeof localRequestAnimationFrame !== 'function') {\n          console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n        }\n\n        if (typeof localCancelAnimationFrame !== 'function') {\n          console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n        }\n      }\n\n      var scheduledCallback = null;\n      var isIdleScheduled = false;\n      var timeoutTime = -1;\n      var isAnimationFrameScheduled = false;\n      var isPerformingIdleWork = false;\n      var frameDeadline = 0; // We start out assuming that we run at 30fps but then the heuristic tracking\n      // will adjust this value to a faster fps if we get more frequent animation\n      // frames.\n\n      var previousFrameTime = 33;\n      var activeFrameTime = 33;\n\n      getFrameDeadline = function () {\n        return frameDeadline;\n      }; // We use the postMessage trick to defer idle work until after the repaint.\n\n\n      var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n\n      var idleTick = function (event) {\n        if (event.source !== window || event.data !== messageKey) {\n          return;\n        }\n\n        isIdleScheduled = false;\n        var currentTime = exports.unstable_now();\n        var didTimeout = false;\n\n        if (frameDeadline - currentTime <= 0) {\n          // There's no time left in this idle period. Check if the callback has\n          // a timeout and whether it's been exceeded.\n          if (timeoutTime !== -1 && timeoutTime <= currentTime) {\n            // Exceeded the timeout. Invoke the callback even though there's no\n            // time left.\n            didTimeout = true;\n          } else {\n            // No timeout.\n            if (!isAnimationFrameScheduled) {\n              // Schedule another animation callback so we retry later.\n              isAnimationFrameScheduled = true;\n              requestAnimationFrameWithTimeout(animationTick);\n            } // Exit without invoking the callback.\n\n\n            return;\n          }\n        }\n\n        timeoutTime = -1;\n        var callback = scheduledCallback;\n        scheduledCallback = null;\n\n        if (callback !== null) {\n          isPerformingIdleWork = true;\n\n          try {\n            callback(didTimeout);\n          } finally {\n            isPerformingIdleWork = false;\n          }\n        }\n      }; // Assumes that we have addEventListener in this environment. Might need\n      // something better for old IE.\n\n\n      window.addEventListener('message', idleTick, false);\n\n      var animationTick = function (rafTime) {\n        isAnimationFrameScheduled = false;\n        var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n\n        if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n          if (nextFrameTime < 8) {\n            // Defensive coding. We don't support higher frame rates than 120hz.\n            // If we get lower than that, it is probably a bug.\n            nextFrameTime = 8;\n          } // If one frame goes long, then the next one can be short to catch up.\n          // If two frames are short in a row, then that's an indication that we\n          // actually have a higher frame rate than what we're currently optimizing.\n          // We adjust our heuristic dynamically accordingly. For example, if we're\n          // running on 120hz display or 90hz VR display.\n          // Take the max of the two in case one of them was an anomaly due to\n          // missed frame deadlines.\n\n\n          activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n        } else {\n          previousFrameTime = nextFrameTime;\n        }\n\n        frameDeadline = rafTime + activeFrameTime;\n\n        if (!isIdleScheduled) {\n          isIdleScheduled = true;\n          window.postMessage(messageKey, '*');\n        }\n      };\n\n      requestCallback = function (callback, absoluteTimeout) {\n        scheduledCallback = callback;\n        timeoutTime = absoluteTimeout;\n\n        if (isPerformingIdleWork) {\n          // If we're already performing idle work, an error must have been thrown.\n          // Don't wait for the next frame. Continue working ASAP, in a new event.\n          window.postMessage(messageKey, '*');\n        } else if (!isAnimationFrameScheduled) {\n          // If rAF didn't already schedule one, we need to schedule a frame.\n          // TODO: If this rAF doesn't materialize because the browser throttles, we\n          // might want to still have setTimeout trigger rIC as a backup to ensure\n          // that we keep performing work.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrameWithTimeout(animationTick);\n        }\n      };\n\n      cancelCallback = function () {\n        scheduledCallback = null;\n        isIdleScheduled = false;\n        timeoutTime = -1;\n      };\n    }\n\n    exports.unstable_scheduleWork = unstable_scheduleWork;\n    exports.unstable_cancelScheduledWork = unstable_cancelScheduledWork;\n  })();\n}","map":{"version":3,"names":["process","env","NODE_ENV","Object","defineProperty","exports","value","DEFERRED_TIMEOUT","firstCallbackNode","isPerformingWork","isHostCallbackScheduled","hasNativePerformanceNow","performance","now","timeRemaining","remaining","getFrameDeadline","Date","deadlineObject","didTimeout","ensureHostCallbackIsScheduled","timesOutAt","cancelCallback","requestCallback","flushWork","flushFirstCallback","node","flushedNode","next","previous","callback","currentTime","unstable_now","unstable_scheduleWork","options","undefined","timeout","newNode","unstable_cancelScheduledWork","callbackNode","localDate","localSetTimeout","setTimeout","localClearTimeout","clearTimeout","localRequestAnimationFrame","requestAnimationFrame","localCancelAnimationFrame","cancelAnimationFrame","ANIMATION_FRAME_TIMEOUT","rAFID","rAFTimeoutID","requestAnimationFrameWithTimeout","timestamp","Performance","window","timeoutID","absoluteTimeout","_schedMock","impl","console","error","scheduledCallback","isIdleScheduled","timeoutTime","isAnimationFrameScheduled","isPerformingIdleWork","frameDeadline","previousFrameTime","activeFrameTime","messageKey","Math","random","toString","slice","idleTick","event","source","data","animationTick","addEventListener","rafTime","nextFrameTime","postMessage"],"sources":["/Users/payhada-user/IdeaProjects/react-oauth2/node_modules/schedule/cjs/schedule.development.js"],"sourcesContent":["/** @license React v16.5.2\n * schedule.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/* eslint-disable no-var */\n\n// TODO: Currently there's only a single priority level, Deferred. Will add\n// additional priorities.\nvar DEFERRED_TIMEOUT = 5000;\n\n// Callbacks are stored as a circular, doubly linked list.\nvar firstCallbackNode = null;\n\nvar isPerformingWork = false;\n\nvar isHostCallbackScheduled = false;\n\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\nvar timeRemaining;\nif (hasNativePerformanceNow) {\n  timeRemaining = function () {\n    // We assume that if we have a performance timer that the rAF callback\n    // gets a performance timer value. Not sure if this is always true.\n    var remaining = getFrameDeadline() - performance.now();\n    return remaining > 0 ? remaining : 0;\n  };\n} else {\n  timeRemaining = function () {\n    // Fallback to Date.now()\n    var remaining = getFrameDeadline() - Date.now();\n    return remaining > 0 ? remaining : 0;\n  };\n}\n\nvar deadlineObject = {\n  timeRemaining: timeRemaining,\n  didTimeout: false\n};\n\nfunction ensureHostCallbackIsScheduled() {\n  if (isPerformingWork) {\n    // Don't schedule work yet; wait until the next time we yield.\n    return;\n  }\n  // Schedule the host callback using the earliest timeout in the list.\n  var timesOutAt = firstCallbackNode.timesOutAt;\n  if (!isHostCallbackScheduled) {\n    isHostCallbackScheduled = true;\n  } else {\n    // Cancel the existing host callback.\n    cancelCallback();\n  }\n  requestCallback(flushWork, timesOutAt);\n}\n\nfunction flushFirstCallback(node) {\n  var flushedNode = firstCallbackNode;\n\n  // Remove the node from the list before calling the callback. That way the\n  // list is in a consistent state even if the callback throws.\n  var next = firstCallbackNode.next;\n  if (firstCallbackNode === next) {\n    // This is the last callback in the list.\n    firstCallbackNode = null;\n    next = null;\n  } else {\n    var previous = firstCallbackNode.previous;\n    firstCallbackNode = previous.next = next;\n    next.previous = previous;\n  }\n\n  flushedNode.next = flushedNode.previous = null;\n\n  // Now it's safe to call the callback.\n  var callback = flushedNode.callback;\n  callback(deadlineObject);\n}\n\nfunction flushWork(didTimeout) {\n  isPerformingWork = true;\n  deadlineObject.didTimeout = didTimeout;\n  try {\n    if (didTimeout) {\n      // Flush all the timed out callbacks without yielding.\n      while (firstCallbackNode !== null) {\n        // Read the current time. Flush all the callbacks that expire at or\n        // earlier than that time. Then read the current time again and repeat.\n        // This optimizes for as few performance.now calls as possible.\n        var currentTime = exports.unstable_now();\n        if (firstCallbackNode.timesOutAt <= currentTime) {\n          do {\n            flushFirstCallback();\n          } while (firstCallbackNode !== null && firstCallbackNode.timesOutAt <= currentTime);\n          continue;\n        }\n        break;\n      }\n    } else {\n      // Keep flushing callbacks until we run out of time in the frame.\n      if (firstCallbackNode !== null) {\n        do {\n          flushFirstCallback();\n        } while (firstCallbackNode !== null && getFrameDeadline() - exports.unstable_now() > 0);\n      }\n    }\n  } finally {\n    isPerformingWork = false;\n    if (firstCallbackNode !== null) {\n      // There's still work remaining. Request another callback.\n      ensureHostCallbackIsScheduled(firstCallbackNode);\n    } else {\n      isHostCallbackScheduled = false;\n    }\n  }\n}\n\nfunction unstable_scheduleWork(callback, options) {\n  var currentTime = exports.unstable_now();\n\n  var timesOutAt;\n  if (options !== undefined && options !== null && options.timeout !== null && options.timeout !== undefined) {\n    // Check for an explicit timeout\n    timesOutAt = currentTime + options.timeout;\n  } else {\n    // Compute an absolute timeout using the default constant.\n    timesOutAt = currentTime + DEFERRED_TIMEOUT;\n  }\n\n  var newNode = {\n    callback: callback,\n    timesOutAt: timesOutAt,\n    next: null,\n    previous: null\n  };\n\n  // Insert the new callback into the list, sorted by its timeout.\n  if (firstCallbackNode === null) {\n    // This is the first callback in the list.\n    firstCallbackNode = newNode.next = newNode.previous = newNode;\n    ensureHostCallbackIsScheduled(firstCallbackNode);\n  } else {\n    var next = null;\n    var node = firstCallbackNode;\n    do {\n      if (node.timesOutAt > timesOutAt) {\n        // The new callback times out before this one.\n        next = node;\n        break;\n      }\n      node = node.next;\n    } while (node !== firstCallbackNode);\n\n    if (next === null) {\n      // No callback with a later timeout was found, which means the new\n      // callback has the latest timeout in the list.\n      next = firstCallbackNode;\n    } else if (next === firstCallbackNode) {\n      // The new callback has the earliest timeout in the entire list.\n      firstCallbackNode = newNode;\n      ensureHostCallbackIsScheduled(firstCallbackNode);\n    }\n\n    var previous = next.previous;\n    previous.next = next.previous = newNode;\n    newNode.next = next;\n    newNode.previous = previous;\n  }\n\n  return newNode;\n}\n\nfunction unstable_cancelScheduledWork(callbackNode) {\n  var next = callbackNode.next;\n  if (next === null) {\n    // Already cancelled.\n    return;\n  }\n\n  if (next === callbackNode) {\n    // This is the only scheduled callback. Clear the list.\n    firstCallbackNode = null;\n  } else {\n    // Remove the callback from its position in the list.\n    if (callbackNode === firstCallbackNode) {\n      firstCallbackNode = next;\n    }\n    var previous = callbackNode.previous;\n    previous.next = next;\n    next.previous = previous;\n  }\n\n  callbackNode.next = callbackNode.previous = null;\n}\n\n// The remaining code is essentially a polyfill for requestIdleCallback. It\n// works by scheduling a requestAnimationFrame, storing the time for the start\n// of the frame, then scheduling a postMessage which gets scheduled after paint.\n// Within the postMessage handler do as much work as possible until time + frame\n// rate. By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\n// We capture a local reference to any global, in case it gets polyfilled after\n// this module is initially evaluated. We want to be using a\n// consistent implementation.\nvar localDate = Date;\n\n// This initialization code may run even on server environments if a component\n// just imports ReactDOM (e.g. for findDOMNode). Some environments might not\n// have setTimeout or clearTimeout. However, we always expect them to be defined\n// on the client. https://github.com/facebook/react/pull/13088\nvar localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\nvar localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\n\n// We don't expect either of these to necessarily be defined, but we will error\n// later if they are missing on the client.\nvar localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\nvar localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\n\n// requestAnimationFrame does not run when the tab is in the background. If\n// we're backgrounded we prefer for that work to happen so that the page\n// continues to load in the background. So we also schedule a 'setTimeout' as\n// a fallback.\n// TODO: Need a better heuristic for backgrounded work.\nvar ANIMATION_FRAME_TIMEOUT = 100;\nvar rAFID;\nvar rAFTimeoutID;\nvar requestAnimationFrameWithTimeout = function (callback) {\n  // schedule rAF and also a setTimeout\n  rAFID = localRequestAnimationFrame(function (timestamp) {\n    // cancel the setTimeout\n    localClearTimeout(rAFTimeoutID);\n    callback(timestamp);\n  });\n  rAFTimeoutID = localSetTimeout(function () {\n    // cancel the requestAnimationFrame\n    localCancelAnimationFrame(rAFID);\n    callback(exports.unstable_now());\n  }, ANIMATION_FRAME_TIMEOUT);\n};\n\nif (hasNativePerformanceNow) {\n  var Performance = performance;\n  exports.unstable_now = function () {\n    return Performance.now();\n  };\n} else {\n  exports.unstable_now = function () {\n    return localDate.now();\n  };\n}\n\nvar requestCallback;\nvar cancelCallback;\nvar getFrameDeadline;\n\nif (typeof window === 'undefined') {\n  // If this accidentally gets imported in a non-browser environment, fallback\n  // to a naive implementation.\n  var timeoutID = -1;\n  requestCallback = function (callback, absoluteTimeout) {\n    timeoutID = setTimeout(callback, 0, true);\n  };\n  cancelCallback = function () {\n    clearTimeout(timeoutID);\n  };\n  getFrameDeadline = function () {\n    return 0;\n  };\n} else if (window._schedMock) {\n  // Dynamic injection, only for testing purposes.\n  var impl = window._schedMock;\n  requestCallback = impl[0];\n  cancelCallback = impl[1];\n  getFrameDeadline = impl[2];\n} else {\n  if (typeof console !== 'undefined') {\n    if (typeof localRequestAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n    if (typeof localCancelAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n  }\n\n  var scheduledCallback = null;\n  var isIdleScheduled = false;\n  var timeoutTime = -1;\n\n  var isAnimationFrameScheduled = false;\n\n  var isPerformingIdleWork = false;\n\n  var frameDeadline = 0;\n  // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n\n  getFrameDeadline = function () {\n    return frameDeadline;\n  };\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n  var idleTick = function (event) {\n    if (event.source !== window || event.data !== messageKey) {\n      return;\n    }\n\n    isIdleScheduled = false;\n\n    var currentTime = exports.unstable_now();\n\n    var didTimeout = false;\n    if (frameDeadline - currentTime <= 0) {\n      // There's no time left in this idle period. Check if the callback has\n      // a timeout and whether it's been exceeded.\n      if (timeoutTime !== -1 && timeoutTime <= currentTime) {\n        // Exceeded the timeout. Invoke the callback even though there's no\n        // time left.\n        didTimeout = true;\n      } else {\n        // No timeout.\n        if (!isAnimationFrameScheduled) {\n          // Schedule another animation callback so we retry later.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrameWithTimeout(animationTick);\n        }\n        // Exit without invoking the callback.\n        return;\n      }\n    }\n\n    timeoutTime = -1;\n    var callback = scheduledCallback;\n    scheduledCallback = null;\n    if (callback !== null) {\n      isPerformingIdleWork = true;\n      try {\n        callback(didTimeout);\n      } finally {\n        isPerformingIdleWork = false;\n      }\n    }\n  };\n  // Assumes that we have addEventListener in this environment. Might need\n  // something better for old IE.\n  window.addEventListener('message', idleTick, false);\n\n  var animationTick = function (rafTime) {\n    isAnimationFrameScheduled = false;\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If we get lower than that, it is probably a bug.\n        nextFrameTime = 8;\n      }\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n    frameDeadline = rafTime + activeFrameTime;\n    if (!isIdleScheduled) {\n      isIdleScheduled = true;\n      window.postMessage(messageKey, '*');\n    }\n  };\n\n  requestCallback = function (callback, absoluteTimeout) {\n    scheduledCallback = callback;\n    timeoutTime = absoluteTimeout;\n    if (isPerformingIdleWork) {\n      // If we're already performing idle work, an error must have been thrown.\n      // Don't wait for the next frame. Continue working ASAP, in a new event.\n      window.postMessage(messageKey, '*');\n    } else if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger rIC as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      requestAnimationFrameWithTimeout(animationTick);\n    }\n  };\n\n  cancelCallback = function () {\n    scheduledCallback = null;\n    isIdleScheduled = false;\n    timeoutTime = -1;\n  };\n}\n\nexports.unstable_scheduleWork = unstable_scheduleWork;\nexports.unstable_cancelScheduledWork = unstable_cancelScheduledWork;\n  })();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}